# Kalev Keil - EPITA International BSc Python for Web Development
Submitted December 2023

----------
##  Uber Project Overview
----------

This project aims to replicate a similar design and functionality of the drive/ride experience of the Uber web application using two main components flask and htmx.

## Flask and Htmx

Flask is used as the backend server to handle routing, database connections and sockets.

Since Flask is used as the backend and supports templating, htmx was used to make an interactive UI. Almost all routes are handled using htmx to return html responses rather json.

Htmx is hosted locally instead of using the cdn in order to make some changes to the codebase.

One important change is exposing the *parseHTML function*  which is used to also handle parsing HTML responses with socketio.


    
    var htmx = {
                parseHTML: parseHTML, // @kodev
                onLoad: onLoadHelper,
                ...
      } 
    ...
    function parseHTML(resp, depth) {
                var parser = new DOMParser();
                var responseDoc = parser.parseFromString(resp, "text/html");
                /** @type {Element} */
                var responseNode = responseDoc.body;
                while (depth > 0) {
                    depth--;
                    // @ts-ignore
                    responseNode = responseNode.firstChild;
                }
                if (responseNode == null) {
                    // @ts-ignore
                    responseNode = getDocument().createDocumentFragment();
                }
                return responseNode;
            }


Here is the project structure:


    🗃️ PyWebUber
    ├─ 📱app.py
    ├─ 🧰requirements.txt
    ├─ 🏗️setup.json
    ├─ 📃READ_ME.md (+ pdf)
    ├─ 📂static ...
    ├─ 🖼️templates...
    ├─ 👤account_bp...
    │  └─ account.py
    ├─ 🔞admin_bp...
    │  └─ admin.py
    ├─ 🔐auth_bp...
    │  └─ auth.py
    ├─ 🗨️chat_bp...
    │  └─ chat.py
    ├─ 👮drivers_bp...
    │  └─ drivers.py
    ├─ ⚫general_bp...
    │  └─ general.py
    ├─ 🗺️locations_bp...
    │  └─ locations.py
    ├─ 🚗riders_bp...
    │  └─ riders.py
    └─ 🛠️utils...

©generated by Project Tree Generator


## 🧰 **Requirements**
----------

Main Dependencies:

- **Backend**
    - Flask
    - Flask-APScheduler
    - Flask-BabelEx
    - Flask-JWT-Extended
    - Flask-Login
    - Flask-Mail
    - Flask-Redis
    - Flask-SocketIO
    - Flask-SQLAlchemy
    - Flask-WTF
    - geopy
    - Pymongo
    - Gmail
    - Flask-monitoringdashboard *

* imported directly into the project rather than as a package

All other backend dependencies are listed in the requirements.txt file
You can install all the requirements by running the following command from the project folder:


    pip install -r requirements.txt

Once the requirements are installed you can head over to [Quick Start](https://www.dropbox.com/scl/fi/lm95vick738gk1stzgus6/Untitled-1.paper?rlkey=pptyrhikb2ydpnykw9gvxv0mu&dl=0#:uid=192188464432238466038961&h2=%F0%9F%9F%A2-Quick-Start).


- **Frontend**
    - htmx and relevant extensions
    - maplibregl
    - tailwindcss - cdn is used for simplicity (there are some dynamic styles so the typical tailwind setup may purge some required files)
    
- **APIs**
    - LocationIQ
    
## 🟢 Quick Start
----------

 **After installing** [**requirements**](https://www.dropbox.com/scl/fi/jeyr78bk1ahmah58gqyxw/Kalev-Keil-EPITA-International-BSc-Design-Patterns.paper?dl=0&rlkey=mqu0heacg308ymflha0ow6sjw#:uid=163039933560630887676146&h2=%F0%9F%A7%B0-Requirements) 
 
The app must first be run in setup mode to set up some database dependencies. In the env file, change the FLASK_ENV variable value to setup. **NB: This is only required to be done once.**

**Alternatively:** you can run the setup.py file directly from within the utils module. This method does not require changing any env variables.
 
From the main project directory run:

     python app.py

Once you receive all the setup messages in the console, you can then change the FLASK_ENV variable value to development and you can rerun the previous command. The development server should start and you can visit the browser at the displayed link.

## 🧱 Project Components
----------
## ⚙️ Utils

**codes.py**
This file handles the conversion of HTTP codes to more common names for ease of use throughout the project.

**config.py**
This file contains the Config object for flask configuration and other configuration variables for the rest of the project.

**extensions.py**
This file initializes all the project extensions allowing them to be used in separate blueprints and aims to avoid circular imports.
Flask-babel and babel are used  to handle translations and currency conversions (prices are calculated in USD but displayed in the user’s preferred locale)

**error_handlers.py**
This file initializes the main application error handlers for different response codes.

Each error handler is set up in a similar way to handle both htmx_requests as well non-htmx requests.  If the request is an htmx_request, simply retarget to the entire body which will handle updating the dom with the relevant methods


    def init_code_error_handlers(app):
        @app.errorhandler(CODES.NOT_FOUND)
        def abort_not_found(e):
            resp = make_response(render_template('codes/err_code.html', code=str(CODES.NOT_FOUND), message="Page Not Found!"))
            if 'hx-request' in request.headers:
                resp.headers['HX-Retarget'] = 'body'
            return resp
    
        ...



**helper.py**
This file contains some helper functions that are global to the project. Each helper function and its parameters are explained in their corresponding docstrings.

Some important helper functions and decorators include:

**Resolve redirect: this is used throughout the project to handle redirects via htmx or using flask**


    def resolve_redirect(endpoint, message=None):
        """ Resolves redirect based on request type
            :param endpoint: endpoint to redirect to
            :param message: message to be flashed
        """
        redirect_method = htmx_redirect if 'hx-request' in request.headers else redirect
        if message:
            flash(message.get('text', 'Notification'), message.get('type' ,'success'))
        return redirect_method(endpoint, code=302)
    
    NB: here htmx_redirect
    
    def htmx_redirect(endpoint, code=200):
        """ Redirects to endpoint with htmx headers 
            :param endpoint: endpoint to redirect to
            :param code: status code to be returned
        """
        response = Response()
        response.headers["HX-Redirect"] = endpoint
        response.status_code = code
        return response


**@htmx_request: checks if the request headers contain hx-request**


    def htmx_request(view_func): 
        """ Decorator to check if request is htmx request 
            :param view_func: view function to be decorated
        """
        def wrapper_func(*args, **kwargs): 
            if 'hx-request' in request.headers: 
                return view_func(*args, **kwargs) 
            else: 
                return {}, CODES.NO_CONTENT
        wrapper_func.__name__ = view_func.__name__
        return wrapper_func


**@roles_required: checks if a user has permissions before accessing a given route**
I also provided a fallback enpoint to route to in the event the the user should be redirected to another page instead of aborting with the code 401
NB **socket_roles_required works in a similar way**


    # extended to allow for many roles
    def roles_required(route_required_roles: list = [], fallback_endpoint=None):
        """ Decorator to check if user has required roles to access a route
            :param route_required_roles: list of roles required to access route as strings
        """
        def wrapper(view):
            @login_required
            def role_check(*args, **kwargs):
                has_role = False
                for role in route_required_roles:
                    if current_user.has_role(role):
                        has_role = True
                        break
                if not has_role:
                    if fallback_endpoint:
                        # print(fallback_endpoint, 'has been called')
                        return resolve_redirect(url_for(fallback_endpoint))
                    return abort(CODES.UNAUTHORIZED)
                return view(*args, **kwargs)
            role_check.__name__ = view.__name__
            return role_check
        return wrapper 


**models.py**
This file sets up the SQL database models as subclasses of the declarative base class as well as the methods required for each method.

The User Model is stores all user basic user information and provides many instance and static methods to simplify common database operations.

Here is a sample of the user model with the static methods to get users by a  certain criteria or add users to the db. Some important instance methods shown below include checking password hashes using *werkzeug.security check_password_hash* and checking and adding roles of users.


    class User(db.Model, UserMixin):
        __tablename__ = 'users'
        id = mapped_column(db.Integer, primary_key=True, autoincrement=True)
        fname = mapped_column(db.String(50), nullable=False)
        lname = mapped_column(db.String(50), nullable=False)
        email = mapped_column(db.String(255), unique =True, nullable=False)
        password = mapped_column(db.String(255), nullable=True)
        user_since = mapped_column(db.DateTime(timezone=True), nullable=False,server_default=func.now())
        profile_pic = mapped_column(db.String(255), nullable=True)
        phone = mapped_column(PhoneNumberType, nullable=True)
        roles = relationship('Role', secondary='user_roles')
        def __repr__(self):
            return f"ID: {self.id}, NAME: {self.display_name()} ROLES: {self.roles}"
        @staticmethod
        def get_by_id(user_id : int):
            """ get user by id
                :param user_id: user id
            """
            return db.session.scalars(db.select(User).filter_by(id=user_id)).first()
        
        @staticmethod
        def get_by_email(email):
            """ get user by email
                :param email: user email address
            """
            query = db.select(User).filter_by(email=email)
            return  db.session.scalars(query).first()
        
        @staticmethod
        def add_user(user):
            """ add user to db 
                :param user: user object
            """
            assert isinstance(user, User), "User must be an instance of User class"
            db.session.add(user)
            db.session.commit()
        ...
        def check_password(self, password : str):
            """ check if password is correct
                :param password: password to check
            """
            return check_password_hash(self.password, password)
        ...
         def has_role(self, role_name : str):
            """ check if user has a role
                :param role_name: role name
            """
            return any(role.name == role_name for role in self.roles)
    
        def add_role(self, role_name : str):
            """ add role to user
                :param role_name: role name
            """
            role = Role.get_by_name(role_name)
            if role and role not in self.roles:
                self.roles.append(role)
                db.session.commit()


The **Role** model simply defines all the possible roles a user can have i.e. for this application there are: riders, drivers and admins. Below is a snippet of the Role model which uses a private static method `__add_role` to initialize the roles.  There also is a User Roles table which acts as an intermediate table to facilitate the many-to-many relationship between users and and roles (since riders can also be drivers and this supports further extension for adding new roles)


    class Role(db.Model):
        __tablename__ = 'roles'
        id = mapped_column(db.Integer(), primary_key=True)
        name = mapped_column(db.String(50), unique=True)
        ...
        
        @staticmethod
        def _init_roles():
            """ initialize roles """
            roles = ['admin', 'driver', 'rider']
            for role in roles:
                if not Role.get_by_name(role):
                    Role.__add_role(role)
    
        ...
    
    class UserRoles(db.Model):
        """ user roles table 
            Intermediate table for many-to-many relationship between users and roles
        """
        __tablename__ = 'user_roles'
        id = mapped_column(db.Integer(), primary_key=True, autoincrement=True)
        user_id = mapped_column(db.Integer(), db.ForeignKey('users.id', ondelete='CASCADE'))
        role_id = mapped_column(db.Integer(), db.ForeignKey('roles.id', ondelete='CASCADE'))

NB: TokenBlockList was used for the initial JWT implementation of this application and remains as it may return in the future.

**mongo.py**
This file sets up some configuration and basic definitions of the expected document structures for reference. Here is a snippet of the code with comments to help define some expected values of the mongo db documents for a given collection.

    # model for ride options: {name, id, ride_type, image, base_fare, frare_rate, time_rate, capacity}
    
    # model for payment methods: {user_id, method, date, is_starred} *if is paypal, { email }, if is card, { card_number, expiry_date, cvv, country }}, if is cash, { }
    payment_methods = mongo_db['payment_methods']
    
    # model for driver data: {user_id, status, date_added, license_number, license_expirey_date, vehicle_plate, ride_option, license_photo, vehicle_phot}
    driver_data = mongo_db['driver_data']
    gridfs = GridFS(mongo_db)
    
    # model for rider requests { rider_id, created_at, pickup_lat, pickup_lon, pickup_osm_id, dropoff_lat, dropoff_lon, dropoff_osm_id, ride_option, status} * when status is accepted, driver_id, distance, ended_at are added
    # status: pending, accepted, completed, cancelled
    rider_requests = mongo_db['rider_requests']
    
    ...


**notifications.py**
This file handles the notification system through htmx (modals and dropdown toasts) which are used alongside Flask flash messages.

These notifications allow for reuse of a similar notification system throughout the project. It handles Retargeting, Reselecting and Reswapping for new the correct swap method to send via HX-headers to avoid having to do this for each response


    def notify_accept_error_modal(message, header="Bad Request", code=CODES.BAD_REQUEST):
        """Notify the user of an error in the request via modal via htmx"""
        resp = make_response(render_template('htmx/modals/notify-accept.html', message=message, header=header))
        resp.headers['HX-Retarget'] = '#modal-bg'
        resp.headers['Hx-Reswap'] = 'outerHTML'
        resp.headers['Hx-Reselect'] = '#modal-bg'
        resp.status_code = code
        return resp
    
    def notify(message, type, link=None, code=CODES.OK):
        """Notify the user of an error in the request via top dropdown notification via htmx"""
        resp = make_response(render_template('htmx/notif.html', message=message, type=type, link=link))
        resp.headers['HX-Retarget'] = '#messages'
        resp.headers['HX-Reselect'] = '.notif'
        resp.headers['HX-Reswap'] = 'innerHTML'
        resp.status_code = code
        return resp

**setup.py**
Setup file to be run before the project is initialized as discussed in [Quick Start](https://www.dropbox.com/scl/fi/lm95vick738gk1stzgus6/hsdjhdKalev-Keil-EPITA-International-BSc-Design-Patte.paper?rlkey=pptyrhikb2ydpnykw9gvxv0mu&dl=0#:uid=192188464432238466038961&h2=%F0%9F%9F%A2-Quick-Start).


## 🔷 Blueprints

This project is separated into blueprints to handle their respective functionalities. Given that Flask locates templates either in the given app template folder or the specific blueprint folder, each blueprint module follows the given naming conventions to avoid any naming conflicts:

    - Module Name: *<blueprint_name>*_bp
    - Blueprint Py File:*<blueprint_name>*.py
    - Template Folder: *<blueprint_name>*_templates
        - (within template folder):
            - Blueprint specific UI components: *<blueprint_name>*_components
            - HTMX partials: *<blueprint_name>*_htmx
        

Some blueprints may also have some other blueprint-specific files.
These may include:

- forms.py - uses WTForms
- events.py - handles sockets separately from routes.
- respective helper functions. 

Blueprints also have a test.py file for testing functions and routes using unittest where necessary. (not included in the repo)

The main templates folder is thus used for shared templates amongst blueprints where global access is required.

**inter.py***
This blueprint is used to facilitate internationalization using Flask-BabelEx. It is the only blueprint that does not follow the aforementioned structure. This blueprint acts as a parent to all other blueprints and thus is not put into a directory like the others since it has no templates. As recommended by [the flask docs](https://flask.palletsprojects.com/en/2.3.x/patterns/urlprocessors/), this blueprint implements some simple URL processors to access the user’s chosen language, otherwise, it defaults to the default configuration locale (English in this case). 
`Flask.g` is used to store the language on each request which is then used with flask-babel’s `localeselctorfunc` to render templates in the correct language.

Here is the entire blueprint:

    language_str = ', '.join(Config.LANGUAGES)
    default_lang = Config.BABEL_DEFAULT_LOCALE

    inter_bp = Blueprint('inter', __name__, url_prefix=f'/<any({language_str}):lang>')

    @inter_bp.url_value_preprocessor
    def pull_lang(endpoint, values):
        lang = values.pop('lang')
        if lang and lang in Config.LANGUAGES:
            g.lang = lang
        else:
            g.lang = default_lang

    @inter_bp.url_defaults
    def add_language_code(endpoint, values):
        values.setdefault('lang', g.get('lang', default_lang))

Then each of the following blueprints is registered on this parent blueprint.
**admin_bp**
The admin blueprint provides an interface to monitor the application activity and statistics using flask-monitordashboard. The admin portal also handles accepting or denying driver requests. The login credentials for admins are defined within the application.
*email: admin@kuber.co*
*password:admin*

*The application does not currently support registering new admins.*

More about this blueprint in [Usage.](https://www.dropbox.com/scl/fi/lm95vick738gk1stzgus6/hsdjhdKalev-Keil-EPITA-International-BSc-Design-Patte.paper?rlkey=pptyrhikb2ydpnykw9gvxv0mu&dl=0#:uid=555803744194822538702778&h2=%F0%9F%A7%91%E2%80%8D%F0%9F%92%BBUsage)

**auth_bp**
This blueprint is responsible for handling user, session-based authentication using Flask-Login. It aims to replicate the flow process of signing up a user. Redis is used here to store the ‘auth session data’ i.e. data that is accumulated throughout the authentication process. APScheduler is used to expire the authentication codes via email which are used for both logging in and registration.
**NB: the code is printed to the console in case you do not want to use a real email address. You can also use** [**TempMail**](https://temp-mail.org/en/) **for a throwaway email address to view an email**
Login via password is also supported once your account has been set up as is discussed in the following in the [account_bp](https://www.dropbox.com/scl/fi/lm95vick738gk1stzgus6/hsdjhdKalev-Keil-EPITA-International-BSc-Design-Patte.paper?rlkey=pptyrhikb2ydpnykw9gvxv0mu&dl=0#:h2=account_bp).


    *auth_helper.py*
    Some helpers defined within this file aid in maintaining correct functionality across several functions within the auth blueprint as well as other blue prints.
    - This decorator is used to ensure other helper functions are only called within the request context
    def enforce_has_request_context(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            if not has_request_context():
                raise RuntimeError("This method can only be called within a request context")
            return func(*args, **kwargs)
        wrapper.__name__ = func.__name__
        return wrapper
    
    - `get_auth_redis_data` gets a nested key or all the data of key within the reids client using the auth session id set  with the request headers
    @enforce_has_request_context
    def get_auth_redis_data(key="all"):
        """ gets the auth data from redis, either all or a specific key,
        only to be called from within  a route decorated with auth_session_id_required"""
        auth_session_id = request.headers.get('X-Auth-Session-Id')  
        if key == "all":
            print(redis_client.hgetall(auth_session_id))
            return redis_client.hgetall(auth_session_id)
        else:
            return redis_client.hget(auth_session_id, key)


    - `remove_auth_session_data_code` is used to expire verification codes with redis This is done through the use of a scheduler called within `send_verification_code_email`
    def send_verification_code_email(email,
                                     start_url, 
                                     action,
                                     template_message, 
                                     template_header, 
                                     is_user,
                                     user_name="",
                                     is_driver=False,
                                     next=None
                                     ):
        
        """ sends the verification code to the user via email"""
      ...
    redis_client.hset(inAuthSessionId, mapping=redis_data)
    redis_client.expire(inAuthSessionId, timedelta(minutes=15))
    scheduler.add_job(func=remove_auth_session_data_code, args=[inAuthSessionId], id=f"remove_auth_session_id_{inAuthSessionId}_code", trigger='date', run_date=datetime.now() + timedelta(minutes=15))
    
    
    *middleware*
    There are some important uses of middleware in this blueprint
    - `already_logged_in` ensures that only the logout route can be accessed if the user is the user has successfully logged in to avoid a user going through the authentication process while already being logged in.
    @auth.before_request     
    def already_logged_in():
        """ checks if user is already logged in and redirects to the appropriate page """
        if request.endpoint != 'auth.logout' and current_user.is_authenticated:
            if current_user.has_role('admin'):
                return resolve_redirect(url_for('admin.dashboard.index'))
            return resolve_redirect(url_for('riders.index'))
    
    - `invalidate_auth_session_id` ensures that if an *authSessionId* has been expired via redis, then this change is also reflected in the session data.
    @auth.before_request
    def invalidate_auth_session_id():
        """ invalidates the auth session id if it does not exist in redis """
        auth_session_id = request.headers.get('X-Auth-Session-Id')
        if auth_session_id:
            if not redis_client.exists(auth_session_id):
                session.pop(auth_session_id, None)


    - Since many pages of auth flow have depend on js functions to maintain their frontend functionality, this after_request middleware `add_triggers` ensures that the are correctly sent via HX-headers to be triggered on the frontend. 
        NB: Limited data can be sent via headers so it so it was best to keep these at a minimum
    @auth.after_request
    def add_triggers(response):
        """ add htmx triggers to the response """
        if 'X-Allow-Trigger' in response.headers:
            if "HX-Trigger-After-Swap" not in response.headers:
                response.headers['HX-Trigger-After-Swap'] = "handleCustomInputs"
            else:
                # update the trigger
                response.headers["HX-Trigger-After-Swap"] = json.dumps(json.loads(response.headers["HX-Trigger-After-Swap"]) | {"handleCustomInputs": None})
        return response

**account_bp**
The account blueprint handles basic data for users such as updating profile information and registering for a driver account. This blueprint also handles data for wallet information such as adding or removing payment methods or bank accounts to receive money (for drivers). These are just demo behaviors so no actual authentication of PayPal or card information is done here. This blueprint also handles viewing a users’ trip data either to view all their trips or have mroe

**chat_bp**
This blueprint handles real-time chat between drivers and riders of a given ride using socketio. It also handles the end ride logic since this demo considers a ride to be complete once the chat has been ended by either party
Within the `on message listener` of the socket events,  messages are stored in redis using the time as the score to rank them, thus maintaining their order. Once, the message is stored in Redis, 
the send message and receive messages are emitted to the relevant clients. The send message event skips the sides of all other client side that do not belong the the user that sent the message within the chat room, while the receive message is sent to all those other sids.

    ...
     # store messages in redis
            message_data = {
                'sender':current_user.id,
                'message':data['msg'],
                'created_at':datetime.now().timestamp()
            }
            #  add message to redis sorted set, use timestamp as score for sorting
            redis_client.zadd(f'messages:{roomId}', {json.dumps(message_data): int(message_data['created_at'])})
            # emit send message to chat room to rider and driver
            emit('send message', {'msg': render_template('send-chat.html', is_sender=True, user=current_user, text=data['msg'])}, room=data['room'], include_self=True, skip_sid=list(other_sids)) # skip send messgae to all other user sids and only include sender sids
            emit('receive message', {'msg': render_template('send-chat.html', is_sender=False, user=current_user, text=data['msg'])}, room=data['room'], include_self=False) # receive message to other sids only
    ...


**location_bp**
This blueprint handles any data and backend api calls to the locationIQ API. It is mainly used for its Geocoding through the autocomplete API, the reverse geocoding to convert coordinates to locations and the Directions API for route data to display on maps. 


    *livesearch*
    For the live search functionality, once the user has submitted text of a length greater than 3, the request is considered valid. This is done to avoid calling the API when the search criteria may still be too vague. A front end check and backend check is done to ensure this criteria is met. Once the valid request is sent, the backend makes a request to the LocationsIQ Autocomplete API which returns json objects of the top 10 places which best match the search request. This data is then used to generate some HTML to display the best options that the user can click use to request a ride using the data’s latitude, longitude and osm_id values. 
    
    Search results are cached (locally for simplicity) so that if frequent searches are made, they do not have to be sent as requests to the API, and thus will be returned quicker resulting in less wait time for the user.


    cache = {}
    ...
    @locations.get("/search")
    @roles_required(['rider'])
    @htmx_request
    def search_locations():
        q = request.args.get('pickup') or request.args.get('dropoff')
        # check if query is valid , use min search to avoid most likely useless call to api
        if not q or len(q) < 3:
            return ''
        
        search_type = 'pickup' if 'pickup' in request.args else 'dropoff'
        if q in cache:
            return render_template('locations_htmx/search-results.html', data=cache[q], search_type=search_type)
        
        params = {
            "key": LOCATIONS_API_KEY,
            "q":   q,
            "limit": 10,
        }
        try:
            if FLASK_TESTING:
                data = sample.data
            else:
                r = requests.get(f'{LOCATIONS_API_URL}/autocomplete', params=params)
                if r.status_code != 200:
                    print('Failed at api search location request', r.status_code, r.url)
                    raise Exception('Failed at api search location request')
                
                data = r.json()
                cache[q] = data
        


    *reverse_geocoding*
    Since the user can also set their pickup and drop off on the map, the `/locations/reverse-geocode` endpoint again uses the LocationIQ API to convert the latitude and longitude received from the map to a specific address which can be used to be displayed on the page.
    Below are some snippets to better understand the use of this endpoint and the helper function to go along with it. The geocoded are also cached in MongoDB for a more persistent store of these API calls
    @locations.route('/reverse-geocode')
    @htmx_request
    def reverse_geocode_route():
        """ Reverse geocode a location using location iq api """
        try:
            lat = request.args.get('lat')
            lon = request.args.get('lon')
    
            if not all([lat, lon]):
                raise ValueError('Missing info')
            
            return reverse_geocode(lat, lon, None)
      ...
    
    def reverse_geocode(lat, lon, osm_id):
        """ Reverse geocode a location using location iq api """
        try:
            # check if location is in cache
            geocode = cached_geocodes.find_one({'$or': [
                    {'lat': lat, 'lon': lon},
                    {'osm_id': osm_id}
                ]
            })
            if geocode:
                del geocode['_id']
                return geocode
        
            params = {
                "key": LOCATIONS_API_KEY,
                "lat": lat,
                "lon": lon,
                "format": "json"
            }
            # res = {}
            r = requests.get(f"{LOCATIONS_API_URL}/reverse", params=params)
            if r.status_code != 200:
                raise Exception('Failed to reverse geocode')
            
            res = r.json()

            # cache result as copy since it is changed in place by mongo
            cached_geocodes.insert_one(res.copy())
    
            return res
    
          ...

*finding routes*
LocationIQ also provides an API for finding the best route between two points if possible. The helper function `find_route` makes use of caching the routes obtained from these API calls in MongoDB for the same previously mentioned reasons.

This function takes the lat, lon and osm_id of both the pickup and drop off positions to find a suitable route. The function does some validation checks, again to avoid wasting calls to the API for clearly invalid requests. For example, a check is done to see if the user lat and lon are the same for both points or if the osm_ids are the same, then there positions are considered to be the same. . LocationIQ documentation states that the max value for any route it will calculate is 10,000 km. So the function uses [*geopy*](https://geopy.readthedocs.io/)  distance  to calculate the distance between the points the two points to ensure the points are valid. The cache is checked for a matching route using the lat, lon and osm_ids of the points. If it cannot be found in the cache, the request is sent to the API then the result is cached and returned where applicable


    def find_route(origin_lat, origin_lon, origin_osm_id, destination_lat, destination_lon, destination_osm_id):
        """ Checks if a route is possible between two locations"""
        # print(origin_lat, origin_lon, origin_osm_id, destination_lat, destination_lon, destination_osm_id)
        try:
            # chekc if origin is destination
            if (origin_lat == destination_lat and origin_lon == destination_lon ) or (origin_osm_id == destination_osm_id):
                raise ValueError('Origin cannot be destinatin')
            distance_between = distance((origin_lat, origin_lon), (destination_lat, destination_lon)).km
            # print(distance_between)
            # api is limited to 10,000 km
            if distance_between > 10000 or distance_between < 0.2:
                raise ValueError(f'Route cannot be found {distance_between}')
            route = cached_routes.find_one({
                'origin': origin_osm_id,
                'destination': destination_osm_id,
            })
            if route:
                # print('Found in cache, routing...')
                return route
            
            # format as lon lat for location iq specifications
            origin = f"{origin_lon},{origin_lat}"
            destination = f"{destination_lon},{destination_lat}"
            params = {
                "key": LOCATIONS_API_KEY,
                "steps": "true",
                "alternatives": "false",
                "geometries": "polyline",
                "overview": "full",
            
            }
            url = f"{LOCATIONS_API_URL}/directions/driving/{origin};{destination}"
            directions_result = requests.get(url, params=params)
            # Check if there is at least one route
            if not directions_result:
                raise ValueError('Route cannot be found')
            
            # print("Route is possible!")
            # directions_result.json()) 
            res = directions_result.json()
            cached_routes.insert_one({
                'origin':origin_osm_id,
                'destination': destination_osm_id,
            } | res)
            return res
    
    ...
    

NB: Throughout this project, a lot of js is triggered in response headers using htmx. It must be noted that since route data can be very large, this data cannot be send via headers. The solution here was to create separate `/locations/route-data` endpoint to handle json responses for these route requests. Once a route is found, the relevant js is used to process the response, mainly through the `processRoutingResponse` defined in `*map.js*`

Fare prices for rides are also calculated in this blueprint using the time, distance and type of ride to make price estimates.

**riders_bp**
The riders blueprint handles all the activity done by users with the rider role (any user who signs up is given this role). These activities are centered around the logic concerned with requesting rides

**drivers_bp**
The drivers blueprint is thus responsible for driver activity centered around accepting a given ride.

More details of the previous two blueprints are explained in [Usage.](https://www.dropbox.com/scl/fi/lm95vick738gk1stzgus6/hsdjhdKalev-Keil-EPITA-International-BSc-Design-Patte.paper?rlkey=pptyrhikb2ydpnykw9gvxv0mu&dl=0#:uid=555803744194822538702778&h2=%F0%9F%A7%91%E2%80%8D%F0%9F%92%BBUsage)

**general_bp**
This blueprint handles app data that does not necessarily fall under an umbrella of specificity as the other blueprints. For example, the index page of the website is placed here as it handles the index page for all users.




## 🧑‍💻Usage
----------

This application is intended to be used by drivers, riders, and admins. All users for all roles can log in to their respective accounts or register,by heading to the */auth* route. From here, depending on whether the accounts already exist or the user-specific roles, the user will be redirected to the relevant pages. i.e. riders will be redirected to */riders,*  drivers to */drivers,* and admins will be redirected to */admins/dashboard/overview.* If the user account does not exist, the user will be prompted to register with the relevant information.

**Riders and Drivers**
These roles are considered non-admins and share similar actions. These users can access all routes of the account blueprint to handle updating their personal information such as name, email, profile photo, phone number, and password. 
NB: To update a profile photo users must click on the photo itself which will then prompt the user to select a new photo

If a user is not yet a driver, they can apply through this portal by visiting */account/driver/setup.* To apply to be a driver, the user must have a profile picture, and bank information and fill out the form to apply which is then subject to approval by an admin. Once approved, the user will then be able to view their driver info by visiting */account/driver.*

Both types of users can view their wallet information for making payments (riders) and accepting payments (drivers) by visiting */account/wallet.* From here users can add, remove, or set preferred payment methods using either PayPal or card information (these are used as dummy data so no real verification is done for payment method information)

These users can also view their trips either as riders or as drivers by visiting */account/trips.* This will display all the trips done by the user. You can click on a trip to view more detailed information about a trip such as the time, pickup and dropoff information, time taken, distance, cost, and with whom the ride was done */account/trip/<*trip_id>. Normally once the ride is complete, both the rider and driver are sent a receipt via email. In the detailed trip view, the user can request to resend this receipt.

**Riders**
Riders can visit */riders* to request rides. The user can search for locations using the form which will then perform live search requests using htmx + the locationIQ API from the locations blueprint. Search requests are cached here to avoid API overuse since the number of daily requests is limited as explained in [the locations blueprint](https://www.dropbox.com/scl/fi/lm95vick738gk1stzgus6/hsdjhdKalev-Keil-EPITA-International-BSc-Design-Patte.paper?rlkey=pptyrhikb2ydpnykw9gvxv0mu&dl=0#:h2=location_bp). 
There is also an interface set up for scheduling rides, but for now, this is simply set in the pickup information rather than scheduling the ride for later i.e. the ride will still be executed whenever a driver accepts the ride
Once the request is made, socket events are used to send this data to the relevant drivers so it appears immediately without the driver needing to refresh. The rider is then forwarded to the loading screen while they wait for a driver to accept their ride. They also have the option to cancel the ride at any moment.

**Drivers**
Drivers can view all the riders who have made a valid ride request for the driver’s specific ride type (green, uberX, uber Van etc). Once the driver has received a request, they can accept the request which then removes it from all other drivers' screens using sockets again, then the rider and driver are both redirected  */chat/<role>/<ride_request_id> (where role is either the driver or rider).*  

Once on the chat page, the rider and driver can communicate with a live chat using sockets. When either user leaves the chat, the ride is considered complete and both users are redirected */account/trip/<*trip_id> for that specific trip for their specific role. 
NB: The price shown on the driver receipt is not the same as that displayed on the rider receipt because an automatic 25% is deducted for the driver payment to simulate Uber receiving their fee for accommodating the ride.

**Admins**
The admin interface is made up of two main parts: verifying driver applications and monitoring application behaviour.
The admin can visit the */admin/verify-drivers* page to view the current driver requests and the history of all the approved/rejected requests. The admin can click on any of the current requests to approve or reject the request based on the information sent by the driver. If viewing the history of the driver applications, the admin can view when and by whom the request was handled.

Application monitoring is handled by Flask-MonitoringDashboard which is added to the admin blueprint as a nested blueprint with some minor changes to the package. Some changes made include: 

- adding the option for a custom blueprint configuration
- adding the option to define database path
- removing flask-monitoringdashboard authentication (use auth_bp instead)
- removing the option to add and remove users from the admin panel

This dashboard provides an extensive interface for monitoring request data such as the number of times each route was hit and the median request duration. The daily usage of the application is also measured and stored. This interface also provides some means to enable customization: for example, the admin can change the monitoring level for each endpoint based on the priority of the request as defined by a given admin and they can also choose date ranges to view the application data monitored between two dates. This interface can also display this data as graphs (bar charts and box and whisker plots) which can be exported as a PNG to create a snapshot of the relevant data. 

**Other Features**
Some other features implemented:

- Users can update their language settings (this does not apply to the admin dashboard since it is built using angular - [see the docs](https://flask-monitoringdashboard.readthedocs.io/en/latest/) ) 
    The app currently supports translations into English, French, Spanish, and German. 

 

- Currency and date formats are based on the selected format. Currency conversions are done mainly from USD to EUR but, if other locales are added, this can be easily extended. This is done through a template filter registered on the app level to be used any template globally. 
    @app.template_filter('format_currency')
    def format_currency(value):
        locale_str = get_locale()
        currency_code = get_currency_code(locale_str)
        converted_value = convert_currency(value, 'USD', currency_code)
        return numbers.format_currency(converted_value, currency_code, locale=locale_str)
    
    In `helper.py`:
    def get_currency_code(locale_str):
        """ Gets the currency code for the specified locale
            :param locale_str: locale string to get currency code for
        """
        # Set the locale default or default to None
        try:
            locale.setlocale(locale.LC_MONETARY, locale_str)
        except locale.Error:
            return None
        # Get the formatting parameters for the current locale
        formatting_params = locale.localeconv()
        # Extract the currency code
        currency_code = formatting_params['int_curr_symbol']
        return currency_code
    
    c = CurrencyConverter()
    def convert_currency(value, from_currency, to_currency):
        """ Converts currency from one currency to another
            :param value: value to be converted
            :param from_currency: currency to be converted from
            :param to_currency: currency to be converted to
        """
        try:
            return c.convert(value, from_currency, to_currency)
        except Exception:
            # return original value if conversion fails
            return value


    - There is a catch-all route in the application that is used to help with redirection to the correct endpoint given that the majority of endpoints are nested within the [](https://www.dropbox.com/scl/fi/lm95vick738gk1stzgus6/Kalev-Keil-EPITA-International-BSc-Python-for-Web-Development.paper?rlkey=pptyrhikb2ydpnykw9gvxv0mu&dl=0#:h2=inter.py*)`[inter.py](https://www.dropbox.com/scl/fi/lm95vick738gk1stzgus6/Kalev-Keil-EPITA-International-BSc-Python-for-Web-Development.paper?rlkey=pptyrhikb2ydpnykw9gvxv0mu&dl=0#:h2=inter.py*)` [blueprint](https://www.dropbox.com/scl/fi/lm95vick738gk1stzgus6/Kalev-Keil-EPITA-International-BSc-Python-for-Web-Development.paper?rlkey=pptyrhikb2ydpnykw9gvxv0mu&dl=0#:h2=inter.py*). 
        This allows routes that would otherwise be considered Not Found to be correctly resolved
        The following table provides an example of how some sample routes would be handled
        For this example consider the locale to be en
| Url                  | Endpoint                | How it is handlerd                                                                                                                                                                                                  |
| -------------------- | ----------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| /en/account/wallet   | inter.account.wallet    | Full match from URL to endpoint url rule so it is handled normally                                                                                                                                                  |
| /                    | index (catch-all route) | Handled using the else statement in the route1 check since no path or base is found. Then it is redirected to /en/<br>which is handled by inter.general.index endpoint.                                             |
| /account/wallet      | index                   | This is now a path. So it is handled in the route1 check if block. The user’s current language is appended so the route becomes /en/account/wallet which would then be handled by the endpoint inter.account.wallet |
| /sdsd/account/wallet | index                   | This is handled similarly to the previous one. However, it replaces the first segment of the request path and replaces with the user’s language to become /en/account/wallet which is a valid url                   |

    NB: This route is only hit if no other possible routes in any blueprints are favoured. Also, it is crucial to check if the endpoint is not the index endpoint otherwise this will result in infinite redirects.
    
    @app.route('/')
    @app.route('/<string:base>')
    @app.route('/<path:path>')
    def index(path=None, base=None):
        adapter = app.url_map.bind_to_environ(request.environ)
        # check if route is ok using the current request path with the current language
        default_lang = app.config['BABEL_DEFAULT_LOCALE']
        lang = g.get('lang', default_lang)
        # route1 check
        if path or base:
            route1 = '/' + lang + request.path.rstrip('/')
        else:
            route1 = '/' + lang + '/'
        
        # route2 check
        # check if route is ok if replace the first part of the route with the current language
        route2 = None
        if path and len(path.split('/')) > 1:
            route2 = '/' + lang + '/' + '/'.join(path.split('/')[1:])
        
        try:
            
            # checl if either route or route2 is valid otherwise abort
            endpoint, args = adapter.match(route, method='GET')
            if endpoint and endpoint != request.endpoint:
                return resolve_redirect(url_for(endpoint, **args))
            if route2:
                endpoint, args = adapter.match(route2, method='GET')
                if endpoint and endpoint != request.endpoint:
                    return resolve_redirect(url_for(endpoint, **args))
            raise Exception('No valid endpoint found')
        except Exception as e:
            return abort(CODES.NOT_FOUND)


    Without this endpoint, the last 3 examples of the table would normally return a 404 response which can be misleading when there may be slight user errors in the URL.
    
    **Frontend**
    Many changes were made to flowbite-datepicker for this project's use case.
    - Within the getDatepickerOptions function, these options were added to allow further option config on the date picker element itself.
    // extended functionality for min and max date colors
      var lang = datepickerEl.getAttribute('datepicker-lang');
      var minDate = datepickerEl.getAttribute('datepicker-mindate')
      var maxDate = datepickerEl.getAttribute('datepicker-maxdate')
      var activeColor = datepickerEl.getAttribute('datepicker-activecolor');
    
    
    - New locales were added to change the calendar language based on user settings.
      fr:{
        days: ["Dimanche", "Lundi", "Mardi", "Mercredi", "Jeudi", "Vendredi", "Samedi"],
        daysShort: ["Dim", "Lun", "Mar", "Mer", "Jeu", "Ven", "Sam"],
        daysMin: ["Di", "Lu", "Ma", "Me", "Je", "Ve", "Sa"],
        months: ["Janvier", "Février", "Mars", "Avril", "Mai", "Juin", "Julliet", "Août", "Septembre", "Octobre", "Novembre", "Décembre"],
        monthsShort: ["Jan", "Fév", "Mar", "Avr", "Mai", "Jun", "Jul", "Aoû", "Sep", "Oct", "Nov", "Déc"],
        today: "Aujourd'hui",
        clear: "Effacer",
        titleFormat: "MM y"
      },
      ...
    // locales added for es and de as well
    


    - Theme colors were added for the active color configuration that was added.
     const themeColors = {
      blue: {
       
          600: 'bg-blue-600',
          700: 'bg-blue-700',
          800: 'bg-blue-800',
          ring: 'ring-blue-300',
          border: 'border-blue-700',
        
      },
    
    ... // gray and red also added


    - Positioning and sizing config also added for more flexible positioning of the calendar.
    // extended x and y center option
          x: orientation.find(x => (x === 'left' || x === 'right' || x=='center')) || 'auto',
          y: orientation.find(y => (y === 'top' || y === 'bottom'|| y=='center')) || 'auto',
    
    ...
    if (orientX === 'center') {
          left += (inputWidth - calendarWidth) / 2;
        }
    
    ...
    if (orientY === 'center'){
          top -= (calendarHeight - inputHeight) / 2;
        }


    - Some style changes using tailwind and further functionality changes.
     // added fade of the next and prev buttons
      setPrevBtnDisabled(disabled) {
        this.controls.prevBtn.disabled = disabled;
        this.controls.prevBtn.querySelector('svg').classList.toggle('!text-gray-300', disabled)
      }
    
    ...
    //disable typing in inputs
          inputField.addEventListener('keydown', e => e.preventDefault());
    
    ...
    //change clear btn behavior
      datepicker.setDate(new Date());


**You can view the demo usage by following this link to get a better understanding of the usage and features implemented**


## ❌ Issues Faced
----------


- Managing sockets and rooms as this was the first time using them
- Maintaining data consistency throughout a larger project.
## 📝 Project References
----------
- Uber - For design ideas, icons (see icons.html), and email templates. - https://www.uber.com/
- htmx- https://htmx.org/
- locationIQ - https://locationiq.com/
- Project structuring - https://realpython.com/flask-blueprint/, https://flask.palletsprojects.com/en/2.3.x/patterns/urlprocessors/
- storing messages - https://www.youtube.com/watch?v=miK7xDkDXF0
